옵티마이저 :
사용자가 질의한 sql문에 대한 최적의 실행방법을 결정하는 역할 수행 == 실행 계획
다양한 실행 방법 중 최적의 실행방법을 결정하는 것이 옵티마이저의 역할

비용기반 옵티마이저 : 비용 가장 적게 드는 실행 계획 선택, 비용이란 처리시간/자원
테이블,인덱스 등의 통계정보 혹은 시스템 통계정보 이용
통계정보 없더라도 실행계획 만듦
인덱스 사용비용이 전체 테이블 스캔 비용보다 크다 판단되면 풀스캔 갈김

구성요소 :
1.질의 변환기 : sql문 용이하게 변환
2.비용예측기 : 비용예측
3.대안계획생성기 : 대안 계획 생성

실행계획
위에서 아래, 바깥쪽에서 안쪽으로 읽는다
사용객체, 조인방법, 조인순서, 엑세스패턴등의 정보 출력

인덱스
원하는 데이터를 쉽게 찾을 수 있도록 돕는 책의 찾아보기와 유사한 개념
한 테이블은 0~n개 인덱스 가질 수 있다.
한 테이블에 인덱스가 과도하게 있으면 dml작업시 부하발생

루트,브랜치,리프로 구성
가장 위가 루트, 브랜치 블록은 분기를 목적으로 하는 블록
리프블록은 가장 아래

리프블록은 인덱스를 구성하는 칼럼의 데이터와 해당 데이터를 가지고 잇는 행의 위치를 가리키는 레코드 식별자인 rowid로 구성되어있다.

rowid 구성
데이터 블록 주소 + 로우 번호
데이터 블록 주소는 데이터 파일 번호 + 블록 번호
블록 번호는 데이터 파일 내에서 부여한 상대적 순번
로우 번호는 블록 내 순번

인덱스 스캔 후 추가 정보를 가져오기 위해 table random access를 수행한다.
해당 작업은 dbms 성능 부하의 주 원인이 되며 sql튜닝은 곧 random i/o를 다루는것이다.

싱글블록 io vs 멀티블록 io
싱글블록 io는 인덱스 루트 블록 읽을 때, 인덱스 루트 블록에서 얻은 주소로 브랜치 블록을 읽을 때, 인덱스 브랜치 블록에서 읽은 주소로 리프 블록을 읽을 때,
인덱스 리프블록에서 읽은 주소로 테이블 블록을 읽을 때 발생
주민번호같은 변별력 좋은 칼럼 경우 싱글블록 사용

멀티블록 io는 캐시에서 찾지 못한 특정 블록을 읽으려고 io call을 할 때 디스크 상에 그 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는것이다.
성별과 같은 모호한 칼럼은 멀티블록

풀 테이블 스캔 : 멀티블록 io방법, 재사용성이 낮다 판단하고 버퍼에서 금방 제거할 수 있도록 관리
인덱스 스캔 : 인덱스 리프블록 읽음, 하지만 sql문에서 필요로 하는 칼럼이 모두 인덱스 구성칼럼이라면 테이블을 찾아갈필요없음
인덱스의 칼럼 순서로 정렬된 상태로 반환

인덱스 범위 스캔
인덱스 이용하여 한 건 이상의 데이터 추출하는 방식
특정 범위 스캔하면서 하나하나 리턴

인덱스 유일 스캔
단 하나 데이터 추출
중복 레코드 허용x
반드시 = 조건으로 조회

인덱스 전체 스캔
인덱스를 처음부터 끝까지 전체를 읽으면서 조건에 맞는 데이터 추출
리프블록에 있는 rowid로 테이블의 레코드를 찾아가서 조건에 부합하는지 판단하고 부합하면 해당 행 리턴

인덱스 스킵 스캔
인덱스 선두컬럼이 조건절에 없어도 인덱스 활용하는 스캔방식
조건절에 빠진 인덱스 선두컬럼(성별)의 distinct value의 갯수가 적고, 후행 컬럼(연봉)의 distinct value가 많을 때 유용
루트 또는 브랜치에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 엑세스한다.

인덱스 고속 전체 스캔(index fast full scan)
리프블록들을 멀티블록방식으로 읽어들인다.

인덱스 역순 범위 
인덱스 리프 블록은 doubly linked list방식으로 저장되어있음. 즉 앞뒤로 읽을수잇다.
뒤에서 앞으로 스캔하기에 내림차순 정렬. 스캔 순서를 제외하고는 범위스캔과 동일

풀 테이블 스캔 vs 인덱스 스캔
풀 테이블 스캔 : 항상 이용가능, 한번에 여러 블록 읽음, 많은 데이터 조회 시 성능 상 유리, table random access부하없음, 읽었던 블록 반복해서 읽는 경우 없음
인덱스 스캔 : 인덱스 존재해야만 가능, 한번에 하나 읽음, 극히 일부분 데이터 조회 시 사용, table random access에 의한 부하 발생, 읽었던거 또 읽음

nl조인(oltp에 사용)
대량 데이터 조인시 불리 (random access위주)
한 레코드씩 순차진행
driving테이블 처리 범위에 의해 전체 성능 결정됨
인덱스에 영향 크게 받음
소량 데이터처리, 부분범위처리가능환경에 유리

소트 머지 조인
정렬 작업을 생략가능한 인덱스 존재시 사용
양쪽 집합 정렬한 다음 nl조인함
인덱스 유무 영향 안받음
양쪽 집합을 개별적으로 읽고나서 조인
스캔 위주의 엑세스 방식

해시조인(olap에 사용)
각 테이블에 반드시 인덱스가 필요한것은 아니다
작은 집합을 build input으로 하고 큰 집합을 probe input으로 하는것이 중요
대량 데이터 처리 필요, 대용량 테이블 조인시 사용
random access부하x
정렬 부하x
build input이 hash area에 담길 수 있어야한다.
해쉬함수는 무조건 equi join

조인 순서의 중요성
first table 두 개의 테이블을 조인 시 먼저 처리되는 테이블 , where절에 상수/바인드 변수 조건이 존재하는것이 성능상 유리  outer, driving table, build input이라고 불림
second : 뒤에 처리되는 테이블, 조인조건이 중요,  nl조인의 경우 조인 조건 및 상수/바인드 변수조건에 인덱스 존재 여부가 매우 중요 innter, driven table, probe input이라고 불림
최적화된 join order : first table이 second table에 비해 작은 집합이어야 성능상 유리(nl,hash join의 경우)

인덱스를 구성하며 테이블에 갈 일이 없어야 테이블 필터처리 줄여줌

nl join (nested loop)
인덱스
non-equal (between, >, >=, <, <=)조건 사용가능
oltp, 온라인 프로그램
주로 랜덤 엑세스
선행 테이블이 일량 결정

hash join
= 조건만 사용가능
cpu작업 위주
배치, olap
선행 테이블은 작아야좋다.
인덱스 없을 떄에도 사용가능

sort merge join
non-equal (between, >, >=, <, <=)조건 사용가능
정렬작업 이후 조인
배치, olap


hash join
= 조건만 사용가능
cpu작업 위주
배치, olap
선행 테이블은 작아야좋다.
인덱스 없을 떄에도 사용가능

sort merge join
non-equal (between, >, >=, <, <=)조건 사용가능
정렬작업 이후 조인
배치, olap