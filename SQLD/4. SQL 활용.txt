일반 집합 연산자
1.UNION : UNION기능
2.INTERSECTION : INTERSECT기능
3.DIFFERECE : EXCEPT(ORACLE은 MINUS)
4.PRODUCT : CROSS JOIN기능

순수 관계 연산자
1.SELECT : WHERE절로 구현
2.PROJECT : SELECT절로 구현
3.(NATURAL)JOIN : 다양한 JOIN기능으로 구현
4.DIVIDE : 현재 사용 X

조인의 형태
INNER JOIN
NATURAL JOIN : 두 테이블 간 동일한 이름을 갖는 모든 컬럼들에 대해 EQUI(=)JOIN 수행, 식별자(ALIAS)를 가질 수 없다!!
USING 조건절 : FROM절의 USING조건절 이용하면 같은 이름을 가진 칼럼들 중 원하는 칼럼에 대해서만 선택적으로 EQUI JOIN 가능, 식별자(ALIAS)를 가질 수 없다!!
ON 조건절 
CROSS JOIN : 2건있는 테이블 두 개 JOIN하면 4건 나옴
OUTER JOIN

<OUTER JOIN>
SELECT A.EMP_NO, A.EMP_NM,B.DEPT_CD, B.DEPT_NM
FROM TB_EMP A, TB_DEPT B
WHERE A.DEPT_CD IN ('00000', '100001')
AND A.DEPT_CD = B.DEPT_CD(+)
;

TB_EMP A 테이블을 레프트조인한다( '(+)'가 중요!!)
다 보여주고자 하는 테이블의 기준 컬럼에 (+)를 붙이지 않는다!!
(+)없으면 그냥 INNER JOIN이다.

집합 연산자
1.UNION : 합집합, 중복 행은 하나의 행
2.UNION ALL : 합집합, 중복 행도 출력
3.INTERSECT : 교집합
4.EXCEPT : 차집합 (ORACLE에서는 MINUS)

계층형 질의와 SELF 조인
계층형 질의 : 테이블에 계층 형 데이터가 존재할 경우 조회하기 위해 계층 형 질의(Hierarchical Query)를 사용
계층형 데이터 : 동일 테이블에 계층적으로 상위/하위 데이터가 포함된 데이터

오라클 계층 형 SQL
1.SELECT
2.FROM TABLE
3.WHERE
4.START WITH 조건 : 계층 구조 전개 시작위치 지정. 즉, 루트 데이터 지정
5.CONNECT BY [NOCYCLE] [PRIOR] A AND B : 
CONNECT BY : 다음 전개 자식 데이터
PRIOR 자식 = 부모 : 자식 -> 부모 방향 전개하는 순방향
PRIOR 부모 = 자식 : 부모 -> 자식 방향 전개 역방향
NOCYCLE 추가하면 사이클이 발생한 이후 데이터는 전개하지 않는다.

사용방법 
START WITH A.EMP_NM = '이경오'
CONNECT BY PRIOR A.EMP_NO = A.DIRECT_MANAGER_EMP_NO (자식 -> 부모 순방향)


6. ORDER SIBLINGS BY 칼럼 : 형제 노드 사이에서 정렬 수행

계층 형 질의에서 사용되는 가상 칼럼
LEVEL : 루트데이터면1, 그 하위면 2, 하위데이터가 있을 때마다 1씩 증가
CONNECT_BY_ISLEAF : 전개과정에서 해당 데이터가 리프 데이터(맨 마지막 하위 데이터)이면 1 아니면 0
CONNECT_BY_ISCYCLE : 전개과정에서 자식을 갖는데 해당 데이터가 조상으로서 존재하면1 아니면 0
CONNECT_BY_ROOT : 최상위 관리자 출력
SYS_CONNECT_BY_PATH : 조직인원 경로 출력

SELF JOIN
A.매니저번호 = B.사원번호
하면 A테이블의 상사명이 오른쪽에 붙는다
하지만 셀프 이너조인은 회장은 나오지 않아! 왜냐하면 회장의 상사는 없기 때문
이 때 LEFT OUTER JOIN 사용해서 회장까지 뽑아낼 수 있다.

 서브쿼리
서브쿼리는 메인 쿼리 칼럼 사용 하지만 메인쿼리는 서브 쿼리 칼럼 사용 x

주의점 :
괄호로 감싼다
단일/복수 행 비교 연산자와 사용가능
단일 행 비교 연산자는 서브 쿼리의 결과가 반드시 1건 이하, 복수형은 결과 건수와 관계 x
서브 쿼리에서는 order by 사용불가!! 반드시 메인 쿼리 마지막 문장

사용 가능 위치
select, from, where, having, order by 절
insert문의 values 절, update문의 set 절

동작 방식에 따른 서브쿼리 분류
1. 비연관 서브쿼리 : 서브쿼리가 메인 쿼리 칼럼 가지고 있지 않은 형태, 메인 쿼리에 값 제공하기 위해 사용
2. 연관 서브쿼리 : 서브쿼리가 메인 쿼리 칼럼 가지고 있는 형태, 메인쿼리가 먼저 수행되어 읽혀진 데이터를 서브쿼리에서 조건이 맞는지 확인하고자 할 때 사용

반환 형태에 따른 서브쿼리 분류
1.단일 행 : 서브쿼리 실행 결과가 항상 1건 이하, 항상 비교 연산자(=,<.<=,>,>=,<>)와 함께 사용
2.다중 행 : 서브쿼리 실행 결과가 여러건, 다중 행 비교 연산자(IN,ALL,ANY,SOME,EXISTS)
3.다중 칼럼 : 서브쿼리 실행 결과로 여러 칼럼 반환, 메인 쿼리의 조건 절에 여러 칼럼 동시비교 가능, 서브 쿼리와 메인 쿼리의 칼럼 수/순서 동일해야함

단일행 연산자와 다중 행 연산자를 잘 사용하자

다중칼럼 EX)
WHERE (A.DEPT_CD, A.BIRTH_CD) IN
(
SELECT K.DEPT_CD, MIN(K.BIRTH_CD) //부서별 나이가 가장 많은 사람(최고참) 뽑아내는 SQL문
~
)

스칼라 서브 쿼리 : SELECT절에 들어가는 서브쿼리
주의점은 결과 반환 건수는 1건이어야한다. 2건부터 에러

인라인 뷰 서브쿼리 : FROM절에 들어가는 서브쿼리

HAVING절 서브쿼리

UPDATE문에 사용되는 서브쿼리
ALTER TABLE TB_EMP ADD(DEPT_NM VARCHAR2(150));

UPDATE TB_EMP A
SET A.DEPT_NM = (SELECT K.DEPT_NM FROM TB_DEPT K WHERE K.DEPT_CD = A.DEPT_CD)
;

COMMIT;

INSERT문 서브쿼리

뷰 사용 장점
1.독립성 : 테이블 구조가 변경되어도 뷰를 사용하는 응용프로그램은 변경하지 않아도 된다.
2.편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성가능
3.보안성 : 직원 급여정보와 같이 숨기고 싶은 정보가 존재할 시, 뷰를 생성할 때 해당 칼럼 빼고 생성가능

그룹함수
그룹함수를 이용하여 특정 집합의 소계, 중계, 합계, 총합계를 구할 수 있다.

종류 :
rollup

cube

grouping sets


grouping (컬럼) : 만약 컬럼이 집계된 컬럼이면 1 반환

윈도우 함수 :
행과 행간의 관계에서 다양한 연산처리 할 수 있는 함수
분석함수(ansi표준)
일반함수와 다르게 중첩하여 호출 불가

종류
1.순위관련
rank, dense_rank, row_number
2.집계
sum,max,min,avg,count
3.행순서
first_value,last_value,lag,lead
4.그룹내 비율
cume_dist,percent_rank, ntile, ratio_to_report

문법:
select
윈도우함수(인자) over(partition by 칼럼 order by 칼럼)
윈도우절 (row,range)
from 테이블명


ratio_to_report(a.부서별연봉총액) : 총 부서 중 이 부서의 연봉 비율이 몇퍼센트를 차지하는가
percent_rank() over(order by a.부서별연봉총액) : PERCENT_RANK를 사용하여 쿼리 결과 집합 또는 파티션 내에서 값의 상대 순위를 평가할 수 있습니다.
cume_dist() : CUME_DIST 함수는 주어진 그룹에 대한 상대적인 누적분포도 값을 반환한다. 분포도 값(비율)이므로 반환 값의 범위는 0초과 1이하 사이의 값을 반환한다.
예를들면 13개의 행이 있다면 각 cume_dist()칼럼은 1/13의 비율을 가짐.
각 비율을 누적해서 계산. 0.077, 0.077+0.077=0.154, 0.077+0.077+0.077 = 0.231 ... 
ntile(4) over(order by a.부서별연봉총액): 4등분하여 부서별연봉비율순서별등분결과. 즉 상위 25%, 상위 50%, 상위 75%, 상위 100%를 1,2,3,4로 표기

dcl : 유저 생성, 권한 제어, 데이터의 보호와 보안으 위해서 유저와 권한을 관리해야함

오라클 제공 유저들:
scott : 테스트용 샘플 유저
sys : dba권한 받은 유저 (최고 권한)
system:system데이터베이스 모든 시스템 권한 부여 받은 유저(sys바로 밑)

role을 이용한 권한 부여
유저를 생성하면 다양한 많은 권한들을 부여해야함
dba는 role을 생성하고 role에 각종 권한 부여한 후 해당 role을 다른 유저에게 부여
role에 포함된 권한들이 필요한 유저에게 빠르게 권한 부여가능

create session만 connect role이고 나머지는 다 resource이다.