성능 데이터모델링 : 
데이터 성능향상 목적으로 설계단계 데이터 모델링 때부터 정규화, 반정규화, 테이블통합/분할, 조인구조, pk, fk 등 여러가지 성능과 관련된 사항이 데이터 모델링에 반형될 수 있도록 하는 것으로 정의

성능 데이터 모델링 수행시점 :
사전에 할수록 비용이 적게 든다. (분석/설계, 구현, 테스트, 운영 순으로 비용이 올라간다)
분석/설계단계에서 성능 데이터 모델링 수행할 경우 재업무(rework)비용 최소화 -> 분석/설계 단계에서 처리하자!

성능 데이터 모델링 고려사항 :
1. 데이터 모델링 때 정규화
정규화 된 모델이 데이터를 주요 관심사별로 분산시키는 효과 있음

2. 데이터베이스 용량 산정

3. 데이터베이스에 발생하는 트랜잭션 유형 파악
CRUD 매트릭스, 객체지향 모델링 적용한 시퀀스 다이어그램을 통하여 파악가능

4. 용량과 트랜잭션의 유형에 따라 반 정규화 수행
테이블, 속성, 관계에 대해 포괄적인 반 정규화 방법 적용

5. 이력 모델의 조정, pk/fk 조정, 슈퍼타입/서브타입 조정
PK/FK의 순서가 인덱스 특성에 따라 성능에 영향을 미치는 영향도가 크기 때문에 반드시 PK/FK의 성능이 우수한 순서대로 컬럼 순서 조정

6. 데이터 모델 검증

정규화와 성능 향상 전략: 
1. 데이터를 결정하는 결정자에 의한 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상현상 제거
2. 데이터 중복 속성 제거, 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과
3. 정규화 테이블은 데이터 처리 시 처리 조건에 따라 속도가 빨라질수도 있고 느려질수도 있다.

정규화 데이터 모델은 입력/수정/삭제 시 무조건 성능이 향상!!

정규화(Normalization) : FD등과 같은 이론에 근거하여, 관계형 데이터베이스 테이블의 삽입,삭제,갱신 이상(Anomaly)현상 발생을 최소화 하기 위해 좀 더 작은 단위의 테이블로 설계하는 과정.
즉, 데이터 모델을 정규형에 맞도록 고치는 과정

정규형(NF: Normal Form) : 정규화 규정. 정규화 결과에 의해 도출된 데이터 모델이 갖춰야 할 특성

함수적 종속성(FD: Functional Dependency) : 테이블 특정 컬럼 A의 값을 알면 다른 컬럼 B값을 알 수 있을 때, 컬럼 B는 컬럼 A에 함수적 종속성이 있다고함.
ex) 고객주민등록번호를 알면 고객명을 알 수 있음 == 고객명은 고객주민등록번호에 함수적 종속성이 있음

결정자(Determinant) : FD 설명에서 컬럼 A를 결정자라고 함
ex) 고객주민등록번호

다치종속(MVD: MultiValued Dependency) : 결정자 컬럼 A에 의해 컬럼 B의 값을 다수 개 알 수 있을 때, 컬럼 B는 컬럼 A에 다치종속되어있다고 함.
ex) 학번을 알면 해당 학생의 다수 개 수강과목을 알 수 있을 때, 수강과목은 학번에 다치종속관계임

정규화 효과 및 장점 :
1. 상호 종속성이 강한 데이터 요소 분리, 독립된 개념(엔티티, 테이블)으로 정의하게 됨에 따라 High Cohesion & Loose Coupling 원칙에 충실해지면서 유연성 극대화
High Cohesion & Loose Coupling : 응집도가 높은 모듈(기능단위)은 프로그램 전체에서 담당하는 기능을 수행하는 것에 있어서는 다른 모듈과의 상호작용이 거의 없이도 단일 기능을 수행할 수 있게된다.
2. 개념이 세분화 됨에 따라 재활용 가능성 높아짐(일반적으로 참조 모델은 정규화 만족)
3. Non-Key 데이터 요소가 한번만 표현됨에 따라 중복 최소화 됨(데이터 품질 확보, 저장공간 절약, DML 성능)

정규화 이론:
1. 1차,2차,3차, 보이스코드정규화는 함수종속성 근거 정규화 수행
2. 4차 정규화는 다치종속
3. 5차 정규화는 조인에 의해 발생하는 이상현상 제거로 정규화 수행

문제)1,2,3차 정규화 문제 나온다
제1 정규화 문제는 속성의 원자성 확보 기억
제2정규화 문제는 복합식별자 관련 문제, 왜냐면 단일식별자에서는 2정규화 위반 불가
-> 주식별자가 복합식별자이고 그 중에 외부 식별자 먼저 찾기!!
제3정규화 문제는 단일식별자에서 나올 확률이 크다.

정규화 유형
1. 제1 정규형 : 모든 속성은 원자 값을 가져야 함. 즉 다중 값을 가질 수 있는 속성은 분리되어야함
ex) 회원 엔티티 연락처 컬럼에 휴대폰번호, 이메일 값이 들어가있다 -> 연락처 속성에 두가지 값 들어가 있음 == 제1정규형 위반

위반 해소 : 
기존 회원 엔티티에서 회원 엔티티 추가하여 1정규형 만족시킴

2. 제2 정규형 : 제1정규형 만족, 모든 Non-Key 컬럼은 기본 키 전체에 종속되어야 함.
기본 키에 종속적이지 않거나 기본 키 일부 컬럼(들)에만 종속적인 컬럼은 분리되어야함
부분 종속 속성(Partial dependency attribute)을 분리
ex) 주문 테이블(고객아이디, 주문번호, 주문일자, 고객명, 고객등급) 중 고객아이디, 주문번호가 PK
고객명, 고객등급은 고객아이디에만 종속, 고객아이디+주문번호에 종속적이지 않다.
올바른 집합 단위 x, 갱신 시에 갱신 이상 발생 가능성 존재, 주문 시마다 고객 정보를 저장해야함, 고객 정보의 중복 발생 가능, 고객 정보 모르면 주문 불가

고객주문 엔터티(고객아이디, 주문번호, 주문일자), 고객엔터티(고객아이디, 고객명, 고객등급)으로 분리
-> 모든 속성이 식별자 만으로 함수 종속 가짐, 식별자의 일부에만 종속하는 속성 없음

3. 제3 정규형 : 제2정규형 만족, 일반 속성들간에도 종속관계x, 일반속성들 간 종속관계가 존재하는 것들은 분리해야함.
이전/이행 종속(transitive dependency)속성 분리
ex) 고객엔터티(고객아이디, 고객명, 나이, 직업코드, 직업명) 중 고객아이디가 PK
식별자를 제외한 일반 속성끼리 함수 종속 발생 (직업코드를 알면 직업명을 알 수 있음, 즉, 직업코드가 결정자이다)

고객엔터티(고객아이디, 고객명, 나이, 직업코드)와 직업 엔터티(직업코드, 직업명)로 분리
-> 일반 속성끼리의 함수 종속 제거

정규화와 성능 :
1. 정규화 수행해서(소량 테이블이 많이 생긴다) 조인 발생하게 되더라도 효율적인 인덱스 사용을 통해 연산 수행 시 성능 상 단점 거의 없음
2. 정규화 수행하여 소량 테이블 발생 시, 소량 테이블 먼저 읽어 조인 연산 수행하면 됨
3. 정규화를 한다면 하나의 인덱스만 만들어도 된다.

반정규화의 정의 :
계속 쪼개다 보니 문제 생김 -> 중복, 통합, 분리 등을 수행하는 데이터 모델링
데이터를 중복하여 성능을 향상시키기 위한 기법

반정규화 절차 :
1.반정규화 대상 조사 
2.다른 방법들 고려!!
3.반정규화 적용

반정규화 기법 - 테이블
1.테이블 병합
a. 1:1관계 
b. 1:M관계
c.슈퍼/서브타입

2.테이블 분할
a.수직분할
b.수평분할

3.테이블 추가
a.중복 테이블
b.통계 테이블 : SUM,AVG를 미리 수행하여 계산해둠
c.이력 테이블
d.부분 테이블

반정규화 기법 - 칼럼
1.중복 칼럼 추가
2.파생 칼럼
3.이력 테이블 칼럼
4.PK에 의한 칼럼
5.응용시스템의 오작동을 위한 칼럼

반정규화 기법 - 관계
1.중복관계 추가

테이블과 칼럼의 반정규화는 데이터 무결성에 영향을 미침
관계의 반정규화는 무결성 위험을 깨트리지도 않으면서 데이터 처리 성능 향상

반정규화를 적용 시 데이터 입력,수정,삭제할 때는 성능이 떨어진다.

대량 데이터발생에 따른 테이블 분할 개요
수직 분할 : 칼럼 단위로 분할 I/O 감소
수평 분할 : 로우 단위로 분할 I/O 감소

테이블의 데이터는 Block 단위로 디스크에 저장된다.
칼럼이 많아질 시 하나의 행을 읽더라도 여러개의 블록을 읽어야함 -> SQL문의 Block I/O가 많아진다.

대용량 테이블에서 발생가능한 현상
로우 체이닝 : 로우 길이가 너무 길어서 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
로우 마이그레이션 : 데이터 블록에서 수정 발생 시 수정된 데이터를 해당 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

데이터 조회 시 절대적인 Block I/O의 횟수가 많아지게 된다.
Block I/O의 횟수가 많아지게 되면 Disk I/O 발생 -> 성능이 급격히 저하

한 테이블에 많은 수의 칼럼을 가지고 있는 경우
수직분할 하자! 칼럼별로 쪼개자!

수평분할
1. RANGE PARTITION 적용
ex) 요금 테이블의 PK가 요금일자+요금번호이고 데이터건수가 1억2천건인 경우
요금은 월단위로 데이터 처리를 하는 경우가 많으므로 요금일자를 이용하여 12개의 파티션 테이블 생성
-> 데이터를 쉽게 지우는 것 가능하므로 데이터 관리 용이

2. LIST PARTITION
ex) 고객 테이블에 데이터가 1억건 있는데 하나의 테이블에서 데이터를 처리하기에는 SQL문장의 성능이 저하되어 지역을 나타내는 사업소스코드별로 LIST PARTITION을 적용
LIST PARTITION은 대용량 데이터를 특정 값에 따라 분리 저장 가능하나 RANGE PARTITION과 같이 데이터 보관 주기에 따라 쉽게 삭제하는 기능은 제공 x

3. HASH PARTITION
HASH 조건에 따라 해싱 알고리즘이 적용되어 테이블이 분리된다.
설계자는 테이블에 데이터가 정확하게 어떻게 들어갔는지 알 수 없다.
성능 향상을 위해 사용하여 데이터 보관 주기에 따라 쉽게 삭제하는 기능은 제공 x

테이블에 대한 수평/수직 분할 절차
1. 데이터 모델링 완성
2. 데이터베이스 용량 산정
3 대량 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴 분석
4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블을 분리하는 것 검토  

슈퍼/서브타입 모델
1. 업무 구성 데이터의 특징 분석하여 공통점/차이점 고려 효과적으로 표현가능
2. 공통부분을 슈퍼타입으로 모델링하고 공통으로부터 상속받아 다른 엔터티와 차이가 있을 경우 별도의 서브엔터티로 구분
3. 업무 모습 정확히 표현하면서 물리적인 데이터 모델로 변환 시 선택의 폭 넓힐 수 있는 장점이 있다.

슈퍼/서브타입 모델을 데이터 양,트랜잭션 유형에 따라 1:1, 슈퍼+서브타입, All in One타입으로 변환 (성능 데이터 모델)

트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능 저하 가능
트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능 저하 가능
트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능 저하 가능
-> 개별로 발생하는 트랜잭션에 대해서는 개별 테이블로 구성
슈퍼/서브타입 각각에 대해 독립적으로 트랜잭션 발생 시 슈퍼타입에도 꼭 필요한 속성만을 가지게 하고 서프타입에도 꼭 필요한 속성 및 자신이 타입에 맞는 데이터만 가지게 하기 위해서 모두 분리하여 1:1관계를 갖도록한다.

슈퍼+서브타입 발생하는 트랜잭션에 대해서는 슈퍼+서브타입 테이블로 구성

전체를 하나로 묶어 트랜잭션 발생 시 하나의 테이블로 구성

PK/FK 칼럼 순서와 성능
PK/FK 칼럼 순서를 조정해야한다.

PK가 복합키일 경우 칼럼순서가 성능에 영향 미치는 경우
1. 인덱스 선두 칼럼에 대한 조건이 들어와야한다(가능한 '=' 조건으로)
2. 인덱스 선두 칼럼에 대한 조건이 들어오지 않을 경우 인덱스 전체를 읽거나 테이블 전체를 읽게 됨

ex) 입시마스터 데이블(#수험번호 #년도 #학기 ...) 
select count(수험번호)
from 입시마스터
where 년도 = '2008'
and 학기 = '1';

위의 경우 수험번호 년도 학기 중 수험번호에 대한 값이 where절에 들어오지 않으므로 full table scan 발생

따라서 pk순을 년도 학기 수험번호 순으로 변경하자! -> 해당조건이 '='으로 들어오게 되어 성능 향상됨

ex2) 현금출급기실적 테이블(#거래일자 #사무소코드 #출급기번호 #명세표 번호)
select 건수, 금액
from 현금출급기실적
where 거래일자 between '20040701' and '20040702'
and 사무소코드 = '000368';

위 경우 인덱스 스캔은 가능하나 최적화된 인덱스 사용은 아니다. 왜냐하면 사무소코드를 먼저 찾아봐야하기 때문!
따라서 pk순을 사무소코드 거래일자 순으로 변경한다. 

물리적인 fk제약이 걸려있지 않을 경우 인덱스 미생성으로 성능 저하 -> 테이블 전체를 읽어야하기 때문

분산 데이터베이스와 성능 
분산 데이터베이스 :
여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스

분산 데이터베이스의 투명성(Transparency)
1. 분할 투명성(단편화) : 하나의 논리적 relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
2. 위치 : 데이터 저장 장소 명시 불필요. 위치 정보가 system catalog에 유지되어야함
3. 지역 사상 : 지역 dbms와 물리적 db 사이의 mapping을 보장. 각 지역 시스템 이름과 무관한 이름 사용 가능
4. 중복 : db객체가 여러 site에 중복 되어 있는지 알 필요가 없다. ex)이상혁은 남자다 라는 정보가 여러군데 있어도 볼 때는 하나만 보면 된다.
5. 장애 : 구성요소(DBMS, Computer)의 장애에 무관한 transaction의 원자성 유지 ex)부산에서 문제 생겼다 해서 서울데이터도 영향받지 않는다.
6. 병행 : 다수 transaction 동시 수행 시 결과의 일관성 유지, time stamp, 분산 2단계 Locking 이용 구현

분산 데이터베이스 적용 방법 :
1. 업무의 흐름을 보고 업무 구성에 따른 아키텍처 특징에 따라 데이터베이스 구성
2. 업무 특징에 따라 선택적으로 설계능력 필요

장점 :
빠른 응답 속도와 통신비용 절감
각 지역 사용자의 요구 수용 증대

단점 :
소프트웨어 개발 비용
불규칙한 응답 속도

과거에는 네트워크와 지역별로 분산하였다면
현재는 내부와 외부 이원화된 방식으로 분할하였다.

분산데이터베이스 적용 기법
1. 테이블 위치 분산 : 테이블 위치 다르게
2. 데이블 분할 분산 : 수평/수직 분할
3. 테이블 복제 분산 : 부분(본사 데이터 있고 지사별로 지사에 해당하는 로우를 가지고 있는 형태)/광역(본사와 지사 모두 동일한 데이터) 복제
4. 테이블 요약 분산 : 분석(지사별로 존재하는 요약정보를 본사 데이터 통합 후 다시 전체 대해서 요약정보를 산출)/통합(지사별로 존재하는 다른 내용의 정보를 본사에 통합하여 다시 전체에 대해서 요약정보 산출) 요약

